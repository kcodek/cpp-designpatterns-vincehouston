                                    




// Purpose.  Command design pattern

// 1. Create a class that encapsulates some number of the following:
//       a "receiver" object
//       the method to invoke 
//       the arguments to pass
// 2. Instantiate an object for each "callback"
// 3. Pass each object to its future "sender"
// 4. When the sender is ready to callback to the receiver, it calls execute()

#include <iostream>  
#include <string>  
#include <vector>

using std::cout;
using std::cin;
using std::string;
using std::vector;
using std::endl;

class Person;

class Command {                // 1. Create a class that encapsulates an object and a member function
   Person*  object;            //    
   void (Person::*method)();   // a pointer to a member function (the attribute's name is "method")
public:                        //    
   Command( Person* obj = 0, void (Person::*meth)() = 0 ) {
      object = obj;            // the argument's name is "meth"
      method = meth;
   }
   void execute() {
      (object->*method)();     // invoke the method on the object
}  };

class Person {
   string   name;
   Command  cmd;               // cmd is a "black box", it is a method invoca-
public:                        //    tion promoted to "full object status"
   Person( string n, Command c ) : cmd( c ) {
      name = n;
   }
   void talk() {               // "this" is the sender, cmd has the receiver
      cout << name << " is talking" << endl;
      cmd.execute();           // ask the "black box" to callback the receiver
   }
   void passOn() {
      cout << name << " is passing on" << endl;
      cmd.execute();           // 4. When the sender is ready to callback to
   }                           //    the receiver, it calls execute()
   void gossip() {
      cout << name << " is gossiping" << endl;
      cmd.execute();
   }
   void listen() {
      cout << name << " is listening" << endl;
}  };

int main_command_2( void ) {
   // Fred will "execute" Barney which will result in a call to passOn()
   // Barney will "execute" Betty which will result in a call to gossip()
   // Betty will "execute" Wilma which will result in a call to listen()
   Person wilma(  "Wilma",  Command() );
   // 2. Instantiate an object for each "callback"
   // 3. Pass each object to its future "sender"
   Person betty(  "Betty",  Command( &wilma,  &Person::listen ) );
   Person barney( "Barney", Command( &betty,  &Person::gossip ) );
   Person fred(   "Fred",   Command( &barney, &Person::passOn ) );
   fred.talk();
   return 0;
}

// Fred is talking
// Barney is passing on
// Betty is gossiping
// Wilma is listening




// Purpose.  Simple and "macro" commands
// 
// Discussion.  Encapsulate a request as an object.  
// SimpleCommand maintains a binding between a receiver object and an action stored as a pointer to a member function. 
// MacroCommand maintains a sequence of Commands.  
// No explicit receiver is required because the subcommands already define their receiver.  MacroCommand may contain MacroCommands.


class Number { 
 public:
   void dubble( int& value ) { value *= 2; }
};

class Command1 { 
public: virtual void execute( int& ) = 0; 
};

class SimpleCommand : public Command1 {
   typedef void (Number::* Action)(int&);
   Number* receiver;
   Action  action;
public:
   SimpleCommand( Number* rec, Action act ) {
      receiver = rec;
      action = act;
   }
   /*virtual*/ void execute( int& num ) { (receiver->*action)( num ); }
};

class MacroCommand : public Command1 {
   vector<Command1*> list;
public:
   void add( Command1* cmd ) { list.push_back( cmd ); }
   /*virtual*/ void execute( int& num ) {
      for (int i=0; i < list.size(); i++)
         list[i]->execute( num );
}  };

int main_2( void ) {
   Number object;  //"message": "taking the address of a temporary object of type 'SimpleCommand' [-Waddress-of-temporary]",
   
   Command1* commands[3];
   commands[0] = &SimpleCommand( &object, &Number::dubble );

   MacroCommand two;
   two.add( commands[0] );   
   two.add( commands[0] );
   commands[1] = &two;

   MacroCommand four;
   four.add( &two );   
   four.add( &two );
   commands[2] = &four;

   int num, index;
   while (true) {
      cout << "Enter number selection (0=2x 1=4x 2=16x): ";
      cin >> num >> index;
      commands[index]->execute( num );
      cout << "   " << num << '\n';
}  }

// Enter number selection (0=2x 1=4x 2=16x): 3 0
//    6
// Enter number selection (0=2x 1=4x 2=16x): 3 1
//    12
// Enter number selection (0=2x 1=4x 2=16x): 3 2
//    48
// Enter number selection (0=2x 1=4x 2=16x): 4 0
//    8
// Enter number selection (0=2x 1=4x 2=16x): 4 1
//    16
// Enter number selection (0=2x 1=4x 2=16x): 4 2
//    64




// Purpose.  Command design pattern and inheritance
//
// Discussion.  The Command pattern promotes a deferred method invocation to
// full object status.  Each Command object is a "black box" - it is opaque to
// its holder/user.  Here, a portfolio's heterogeneous collection of financial
// instruments is being treated homogeneously, because, they all inherit from
// a common base class, and, they all have a "convert to currency" method with
// a common signature.

class Instrument { public: virtual ~Instrument() { } };

class IOU : public Instrument {
   int amount;
public:
   IOU( int in ) { amount = in; }
   int payUp() { return amount; }
};

class Check : public Instrument {
   int amount;
public:
   Check( int in ) { amount = in; }
   int cash() { return amount; }
};

class Stock : public Instrument {
   int amount;
public:
   Stock( int in ) { amount = in; }
   int redeem() { return amount; }
};

class Command3 {
public:
   typedef int (Instrument::*Action)();
   Command3( Instrument* o, Action m ) {
      object = o;
      method = m;
   }
   int execute() { return (object->*method)(); }
private:
   Instrument* object;
   Action      method;
};

int main_command_3( void ) {

      // error: taking the address of a temporary object of type  .. 
   Command3* portfolio[] = {  // old C cast, or new RTTI is required
      &Command3( &IOU(100),   (int(Instrument::*)())&IOU::payUp ),
      &Command3( &Check(200), static_cast<int(Instrument::*)()>(&Check::cash) ),
      &Command3( &Stock(300), static_cast<int(Instrument::*)()>(&Stock::redeem) ) };
   
   int netWorth,i;
   for (netWorth=0, i=0; i < 3; i++)
      netWorth += portfolio[i]->execute();
   cout << "net worth is now " << netWorth << '\n';
   return 0;
}

// net worth is now 600



